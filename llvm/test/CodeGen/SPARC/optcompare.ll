; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc < %s -mtriple=sparc | FileCheck %s

define i32 @test(i32 %a) #0 {
; CHECK-LABEL: test:
; CHECK:       ! %bb.0: ! %entry
; CHECK-NEXT:    andcc %o0, 1, %g0
; CHECK-NEXT:    bne .LBB0_1
; CHECK-NEXT:    nop
; CHECK-NEXT:  ! %bb.2: ! %if.end
; CHECK-NEXT:    retl
; CHECK-NEXT:    mov 2, %o0
; CHECK-NEXT:  .LBB0_1: ! %if.then
; CHECK-NEXT:    retl
; CHECK-NEXT:    mov 1, %o0
entry:
  %and = and i32 %a, 1
  %tobool = icmp eq i32 %and, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:
  ret i32 1

if.end:
  ret i32 2
}


; No instruction can be changed to set ICC
define i32 @no_candidate(i32 %a) #0 {
; CHECK-LABEL: no_candidate:
; CHECK:       ! %bb.0: ! %entry
; CHECK-NEXT:    cmp %o0, 0
; CHECK-NEXT:    be .LBB1_2
; CHECK-NEXT:    nop
; CHECK-NEXT:  ! %bb.1: ! %if.then
; CHECK-NEXT:    retl
; CHECK-NEXT:    mov 1, %o0
; CHECK-NEXT:  .LBB1_2: ! %if.end
; CHECK-NEXT:    retl
; CHECK-NEXT:    mov 2, %o0
entry:
  %tobool = icmp eq i32 %a, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:
  ret i32 1

if.end:
  ret i32 2
}

; Defining instruction and compare not in same block
define i32 @not_same_block(i32 %a) #0 {
; CHECK-LABEL: not_same_block:
; CHECK:       ! %bb.0: ! %entry
; CHECK-NEXT:    and %o0, 1, %o0
; CHECK-NEXT:  .LBB2_1: ! %if.then
; CHECK-NEXT:    ! =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    cmp %o0, 0
; CHECK-NEXT:    bne .LBB2_1
; CHECK-NEXT:    nop
; CHECK-NEXT:  ! %bb.2: ! %if.end
; CHECK-NEXT:    retl
; CHECK-NEXT:    mov 2, %o0
entry:
  %and = and i32 %a, 1
  br label %if.then

if.then:
  %tobool = icmp eq i32 %and, 0
  br i1 %tobool, label %if.end, label %if.then
  ret i32 1

if.end:
  ret i32 2
}

; Compare instruction is not checking equality
define i32 @not_equality(i32 %a) #0 {
; CHECK-LABEL: not_equality:
; CHECK:       ! %bb.0: ! %entry
; CHECK-NEXT:    and %o0, 1, %o1
; CHECK-NEXT:    cmp %o1, 0
; CHECK-NEXT:    bl .LBB3_2
; CHECK-NEXT:    nop
; CHECK-NEXT:  ! %bb.1: ! %entry
; CHECK-NEXT:    mov %o1, %o0
; CHECK-NEXT:  .LBB3_2: ! %entry
; CHECK-NEXT:    retl
; CHECK-NEXT:    nop
entry:
  %and = and i32 %a, 1
  %cmp = icmp slt i32 %and, 0
  %cond = select i1 %cmp, i32 %a, i32 %and
  ret i32 %cond
}

; Instruction that modifies ICC (call) between defining
; and compare instruction.
define i32 @call_between(i32 %a) #0 {
; CHECK-LABEL: call_between:
; CHECK:       ! %bb.0: ! %entry
; CHECK-NEXT:    save %sp, -96, %sp
; CHECK-NEXT:    and %i0, 1, %i1
; CHECK-NEXT:    call not_equality
; CHECK-NEXT:    mov %i1, %o0
; CHECK-NEXT:    cmp %i1, 0
; CHECK-NEXT:    be .LBB4_2
; CHECK-NEXT:    nop
; CHECK-NEXT:  ! %bb.1: ! %entry
; CHECK-NEXT:    mov %i1, %i0
; CHECK-NEXT:  .LBB4_2: ! %entry
; CHECK-NEXT:    ret
; CHECK-NEXT:    restore
entry:
  %and = and i32 %a, 1
  call i32 @not_equality(i32 %and)
  %cmp = icmp eq i32 %and, 0
  %cond = select i1 %cmp, i32 %a, i32 %and
  ret i32 %cond
}

; ICC is used in successor block.
define i32 @icc_live_out(i32 %a) #0 {
; CHECK-LABEL: icc_live_out:
; CHECK:       ! %bb.0: ! %entry
; CHECK-NEXT:    and %o0, 1, %o1
; CHECK-NEXT:    cmp %o1, 0
; CHECK-NEXT:    bne .LBB5_4
; CHECK-NEXT:    nop
; CHECK-NEXT:  ! %bb.1: ! %case1
; CHECK-NEXT:    be .LBB5_3
; CHECK-NEXT:    nop
; CHECK-NEXT:  ! %bb.2: ! %case1
; CHECK-NEXT:    mov %o1, %o0
; CHECK-NEXT:  .LBB5_3: ! %case1
; CHECK-NEXT:    retl
; CHECK-NEXT:    nop
; CHECK-NEXT:  .LBB5_4: ! %case2
; CHECK-NEXT:    retl
; CHECK-NEXT:    mov 2, %o0
entry:
  %and = and i32 %a, 1
  %cmp = icmp eq i32 %and, 0
  br i1 %cmp, label %case1, label %case2
case1:
  %cond = select i1 %cmp, i32 %a, i32 %and
  ret i32 %cond
case2:
  ret i32 2
}

attributes #0 = { nounwind }
