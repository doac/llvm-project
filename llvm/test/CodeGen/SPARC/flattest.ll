; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc < %s -mtriple=sparc -disable-fp-elim=false | FileCheck %s
; RUN: llc < %s -mtriple=sparc -disable-fp-elim=true  | FileCheck %s --check-prefix=USEFP

; TODO Add unwind information - remove from attributes - double and single reg. would be leaf functions that uses i0 should not be leaf.
; TODO bigstack - pr28982b

define i32 @test(i32 %a, i32 %b) #0 {
; CHECK-LABEL: test:
; CHECK:         .cfi_startproc
; CHECK-NEXT:  ! %bb.0: ! %entry
; CHECK-NEXT:    sethi 5, %g1
; CHECK-NEXT:    or %g1, 310, %g1
; CHECK-NEXT:    retl
; CHECK-NEXT:    smul %o1, %g1, %o0
;
; USEFP-LABEL: test:
; USEFP:         .cfi_startproc
; USEFP-NEXT:  ! %bb.0: ! %entry
; USEFP-NEXT:    st %l7, [%sp+28]
; USEFP-NEXT:    .cfi_offset %l7, 28
; USEFP-NEXT:    mov %sp, %l7
; USEFP-NEXT:    add %sp, -96, %sp
; USEFP-NEXT:    .cfi_def_cfa_offset 96
; USEFP-NEXT:    sethi 5, %g1
; USEFP-NEXT:    or %g1, 310, %g1
; USEFP-NEXT:    smul %o1, %g1, %o0
; USEFP-NEXT:    mov %l7, %g1
; USEFP-NEXT:    ld [%g1+28], %l7
; USEFP-NEXT:    retl
; USEFP-NEXT:    mov %g1, %sp
entry:
  %0 = mul i32 %b, 5430
  ret i32 %0
}

define i32 @docall() #0 {
; CHECK-LABEL: docall:
; CHECK:         .cfi_startproc
; CHECK-NEXT:  ! %bb.0: ! %entry
; CHECK-NEXT:    st %i7, [%sp+60]
; CHECK-NEXT:    .cfi_offset %i7, 60
; CHECK-NEXT:    mov %o7, %i7
; CHECK-NEXT:    .cfi_register 15, 31
; CHECK-NEXT:    add %sp, -96, %sp
; CHECK-NEXT:    .cfi_def_cfa_offset 96
; CHECK-NEXT:    call func
; CHECK-NEXT:    mov 1, %o0
; CHECK-NEXT:    mov %g0, %o0
; CHECK-NEXT:    mov %i7, %o7
; CHECK-NEXT:    ld [%sp+156], %i7
; CHECK-NEXT:    retl
; CHECK-NEXT:    add %sp, 96, %sp
;
; USEFP-LABEL: docall:
; USEFP:         .cfi_startproc
; USEFP-NEXT:  ! %bb.0: ! %entry
; USEFP-NEXT:    st %l7, [%sp+28]
; USEFP-NEXT:    .cfi_offset %l7, 28
; USEFP-NEXT:    st %i7, [%sp+60]
; USEFP-NEXT:    .cfi_offset %i7, 60
; USEFP-NEXT:    mov %o7, %i7
; USEFP-NEXT:    .cfi_register 15, 31
; USEFP-NEXT:    mov %sp, %l7
; USEFP-NEXT:    add %sp, -96, %sp
; USEFP-NEXT:    .cfi_def_cfa_offset 96
; USEFP-NEXT:    call func
; USEFP-NEXT:    mov 1, %o0
; USEFP-NEXT:    mov %g0, %o0
; USEFP-NEXT:    mov %i7, %o7
; USEFP-NEXT:    mov %l7, %g1
; USEFP-NEXT:    ld [%g1+28], %l7
; USEFP-NEXT:    ld [%g1+60], %i7
; USEFP-NEXT:    retl
; USEFP-NEXT:    mov %g1, %sp
entry:
  %call = tail call i32 @func(i32 1) #4
  ret i32 0
}

define i32 @storeonstack(i32 %a) #0 {
; CHECK-LABEL: storeonstack:
; CHECK:         .cfi_startproc
; CHECK-NEXT:  ! %bb.0: ! %entry
; CHECK-NEXT:    add %sp, -96, %sp
; CHECK-NEXT:    .cfi_def_cfa_offset 96
; CHECK-NEXT:    mov %g0, %g1
; CHECK-NEXT:    st %o0, [%sp+92]
; CHECK-NEXT:    mov %g1, %o0
; CHECK-NEXT:    retl
; CHECK-NEXT:    add %sp, 96, %sp
;
; USEFP-LABEL: storeonstack:
; USEFP:         .cfi_startproc
; USEFP-NEXT:  ! %bb.0: ! %entry
; USEFP-NEXT:    st %l7, [%sp+28]
; USEFP-NEXT:    .cfi_offset %l7, 28
; USEFP-NEXT:    mov %sp, %l7
; USEFP-NEXT:    add %sp, -96, %sp
; USEFP-NEXT:    .cfi_def_cfa_offset 96
; USEFP-NEXT:    mov %g0, %g1
; USEFP-NEXT:    st %o0, [%l7+-4]
; USEFP-NEXT:    mov %g1, %o0
; USEFP-NEXT:    mov %l7, %g1
; USEFP-NEXT:    ld [%g1+28], %l7
; USEFP-NEXT:    retl
; USEFP-NEXT:    mov %g1, %sp
entry:
  %val = alloca i32, align 4
  store volatile i32 %a, i32* %val
  ret i32 0
}

define i32 @storeonstackanddocall(i32 %a) #0 {
; CHECK-LABEL: storeonstackanddocall:
; CHECK:         .cfi_startproc
; CHECK-NEXT:  ! %bb.0: ! %entry
; CHECK-NEXT:    st %i7, [%sp+60]
; CHECK-NEXT:    .cfi_offset %i7, 60
; CHECK-NEXT:    mov %o7, %i7
; CHECK-NEXT:    .cfi_register 15, 31
; CHECK-NEXT:    add %sp, -96, %sp
; CHECK-NEXT:    .cfi_def_cfa_offset 96
; CHECK-NEXT:    st %o0, [%sp+92]
; CHECK-NEXT:    call func
; CHECK-NEXT:    mov 1, %o0
; CHECK-NEXT:    mov %g0, %o0
; CHECK-NEXT:    mov %i7, %o7
; CHECK-NEXT:    ld [%sp+156], %i7
; CHECK-NEXT:    retl
; CHECK-NEXT:    add %sp, 96, %sp
;
; USEFP-LABEL: storeonstackanddocall:
; USEFP:         .cfi_startproc
; USEFP-NEXT:  ! %bb.0: ! %entry
; USEFP-NEXT:    st %l7, [%sp+28]
; USEFP-NEXT:    .cfi_offset %l7, 28
; USEFP-NEXT:    st %i7, [%sp+60]
; USEFP-NEXT:    .cfi_offset %i7, 60
; USEFP-NEXT:    mov %o7, %i7
; USEFP-NEXT:    .cfi_register 15, 31
; USEFP-NEXT:    mov %sp, %l7
; USEFP-NEXT:    add %sp, -96, %sp
; USEFP-NEXT:    .cfi_def_cfa_offset 96
; USEFP-NEXT:    st %o0, [%l7+-4]
; USEFP-NEXT:    call func
; USEFP-NEXT:    mov 1, %o0
; USEFP-NEXT:    mov %g0, %o0
; USEFP-NEXT:    mov %i7, %o7
; USEFP-NEXT:    mov %l7, %g1
; USEFP-NEXT:    ld [%g1+28], %l7
; USEFP-NEXT:    ld [%g1+60], %i7
; USEFP-NEXT:    retl
; USEFP-NEXT:    mov %g1, %sp
entry:
  %val = alloca i32, align 4
  store volatile i32 %a, i32* %val
  %call = tail call i32 @func(i32 1)
  ret i32 0
}

%struct.foo_t = type { i32, i32, i32 }

define void @incomingsret(%struct.foo_t* noalias sret %agg.result, i32 %a, i32 %b, i32 %c) #0 {
; CHECK-LABEL: incomingsret:
; CHECK:         .cfi_startproc
; CHECK-NEXT:  ! %bb.0: ! %entry
; CHECK-NEXT:    ld [%sp+64], %g1
; CHECK-NEXT:    st %o0, [%g1]
; CHECK-NEXT:    st %o1, [%g1+4]
; CHECK-NEXT:    st %o2, [%g1+8]
; CHECK-NEXT:    jmp %o7+12
; CHECK-NEXT:    mov %g1, %o0
;
; USEFP-LABEL: incomingsret:
; USEFP:         .cfi_startproc
; USEFP-NEXT:  ! %bb.0: ! %entry
; USEFP-NEXT:    st %l7, [%sp+28]
; USEFP-NEXT:    .cfi_offset %l7, 28
; USEFP-NEXT:    mov %sp, %l7
; USEFP-NEXT:    add %sp, -96, %sp
; USEFP-NEXT:    .cfi_def_cfa_offset 96
; USEFP-NEXT:    ld [%l7+64], %g1
; USEFP-NEXT:    st %o0, [%g1]
; USEFP-NEXT:    st %o1, [%g1+4]
; USEFP-NEXT:    st %o2, [%g1+8]
; USEFP-NEXT:    mov %g1, %o0
; USEFP-NEXT:    mov %l7, %g1
; USEFP-NEXT:    ld [%g1+28], %l7
; USEFP-NEXT:    jmp %o7+12
; USEFP-NEXT:    mov %g1, %sp
entry:
  %0 = getelementptr inbounds %struct.foo_t, %struct.foo_t* %agg.result, i32 0, i32 0
  store i32 %a, i32* %0, align 4
  %1 = getelementptr inbounds %struct.foo_t, %struct.foo_t* %agg.result, i32 0, i32 1
  store i32 %b, i32* %1, align 4
  %2 = getelementptr inbounds %struct.foo_t, %struct.foo_t* %agg.result, i32 0, i32 2
  store i32 %c, i32* %2, align 4
  ret void
}

define i8* @getret() #0 {
; CHECK-LABEL: getret:
; CHECK:         .cfi_startproc
; CHECK-NEXT:  ! %bb.0: ! %entry
; CHECK-NEXT:    retl
; CHECK-NEXT:    mov %i7, %o0
;
; USEFP-LABEL: getret:
; USEFP:         .cfi_startproc
; USEFP-NEXT:  ! %bb.0: ! %entry
; USEFP-NEXT:    st %l7, [%sp+28]
; USEFP-NEXT:    .cfi_offset %l7, 28
; USEFP-NEXT:    mov %sp, %l7
; USEFP-NEXT:    add %sp, -96, %sp
; USEFP-NEXT:    .cfi_def_cfa_offset 96
; USEFP-NEXT:    mov %i7, %o0
; USEFP-NEXT:    mov %l7, %g1
; USEFP-NEXT:    ld [%g1+28], %l7
; USEFP-NEXT:    retl
; USEFP-NEXT:    mov %g1, %sp
entry:
  %0 = tail call i8* @llvm.returnaddress(i32 0)
  ret i8* %0
}

define i8* @getretandstoreonstack() #0 {
; CHECK-LABEL: getretandstoreonstack:
; CHECK:         .cfi_startproc
; CHECK-NEXT:  ! %bb.0: ! %entry
; CHECK-NEXT:    add %sp, -96, %sp
; CHECK-NEXT:    .cfi_def_cfa_offset 96
; CHECK-NEXT:    st %g0, [%sp+92]
; CHECK-NEXT:    mov %i7, %o0
; CHECK-NEXT:    retl
; CHECK-NEXT:    add %sp, 96, %sp
;
; USEFP-LABEL: getretandstoreonstack:
; USEFP:         .cfi_startproc
; USEFP-NEXT:  ! %bb.0: ! %entry
; USEFP-NEXT:    st %l7, [%sp+28]
; USEFP-NEXT:    .cfi_offset %l7, 28
; USEFP-NEXT:    mov %sp, %l7
; USEFP-NEXT:    add %sp, -96, %sp
; USEFP-NEXT:    .cfi_def_cfa_offset 96
; USEFP-NEXT:    st %g0, [%l7+-4]
; USEFP-NEXT:    mov %i7, %o0
; USEFP-NEXT:    mov %l7, %g1
; USEFP-NEXT:    ld [%g1+28], %l7
; USEFP-NEXT:    retl
; USEFP-NEXT:    mov %g1, %sp
entry:
  %val = alloca i32, align 4
  store volatile i32 0, i32* %val
  %0 = tail call i8* @llvm.returnaddress(i32 0)
  ret i8* %0
}



define internal fastcc i32 @Callee(i32 %i) unnamed_addr #0 {
; CHECK-LABEL: Callee:
; CHECK:         .cfi_startproc
; CHECK-NEXT:  ! %bb.0: ! %entry
; CHECK-NEXT:    st %l7, [%sp+28]
; CHECK-NEXT:    .cfi_offset %l7, 28
; CHECK-NEXT:    mov %sp, %l7
; CHECK-NEXT:    add %sp, -96, %sp
; CHECK-NEXT:    .cfi_def_cfa_offset 96
; CHECK-NEXT:    cmp %o0, 0
; CHECK-NEXT:    be .LBB7_1
; CHECK-NEXT:    nop
; CHECK-NEXT:  ! %bb.2: ! %if.then
; CHECK-NEXT:    mov %sp, %g1
; CHECK-NEXT:    add %g1, -4008, %sp
; CHECK-NEXT:    ba .LBB7_3
; CHECK-NEXT:    ld [%g1+-3912], %o0
; CHECK-NEXT:  .LBB7_1:
; CHECK-NEXT:    mov %g0, %o0
; CHECK-NEXT:  .LBB7_3: ! %return
; CHECK-NEXT:    mov %l7, %g1
; CHECK-NEXT:    ld [%g1+28], %l7
; CHECK-NEXT:    retl
; CHECK-NEXT:    mov %g1, %sp
;
; USEFP-LABEL: Callee:
; USEFP:         .cfi_startproc
; USEFP-NEXT:  ! %bb.0: ! %entry
; USEFP-NEXT:    st %l7, [%sp+28]
; USEFP-NEXT:    .cfi_offset %l7, 28
; USEFP-NEXT:    mov %sp, %l7
; USEFP-NEXT:    add %sp, -96, %sp
; USEFP-NEXT:    .cfi_def_cfa_offset 96
; USEFP-NEXT:    cmp %o0, 0
; USEFP-NEXT:    be .LBB7_1
; USEFP-NEXT:    nop
; USEFP-NEXT:  ! %bb.2: ! %if.then
; USEFP-NEXT:    mov %sp, %g1
; USEFP-NEXT:    add %g1, -4008, %sp
; USEFP-NEXT:    ba .LBB7_3
; USEFP-NEXT:    ld [%g1+-3912], %o0
; USEFP-NEXT:  .LBB7_1:
; USEFP-NEXT:    mov %g0, %o0
; USEFP-NEXT:  .LBB7_3: ! %return
; USEFP-NEXT:    mov %l7, %g1
; USEFP-NEXT:    ld [%g1+28], %l7
; USEFP-NEXT:    retl
; USEFP-NEXT:    mov %g1, %sp
entry:
  %cmp = icmp eq i32 %i, 0
  br i1 %cmp, label %return, label %if.then
if.then:
  %0 = alloca [1000 x i32], align 8
  %.sub = getelementptr inbounds [1000 x i32], [1000 x i32]* %0, i32 0, i32 0
  %conv = load i32, i32* %.sub, align 8
;  %conv = sext i8 %1 to i32
  br label %return

return:
  %retval.0 = phi i32 [ %conv, %if.then ], [ 0, %entry ]
  ret i32  %retval.0
}

define <2 x i32> @bitcast() #0 {
; CHECK-LABEL: bitcast:
; CHECK:         .cfi_startproc
; CHECK-NEXT:  ! %bb.0:
; CHECK-NEXT:    sethi 1049856, %o0
; CHECK-NEXT:    retl
; CHECK-NEXT:    mov %g0, %o1
;
; USEFP-LABEL: bitcast:
; USEFP:         .cfi_startproc
; USEFP-NEXT:  ! %bb.0:
; USEFP-NEXT:    st %l7, [%sp+28]
; USEFP-NEXT:    .cfi_offset %l7, 28
; USEFP-NEXT:    mov %sp, %l7
; USEFP-NEXT:    add %sp, -96, %sp
; USEFP-NEXT:    .cfi_def_cfa_offset 96
; USEFP-NEXT:    sethi 1049856, %o0
; USEFP-NEXT:    mov %g0, %o1
; USEFP-NEXT:    mov %l7, %g1
; USEFP-NEXT:    ld [%g1+28], %l7
; USEFP-NEXT:    retl
; USEFP-NEXT:    mov %g1, %sp
  %1 = bitcast double 5.0 to <2 x i32>
  ret <2 x i32> %1
}

define dso_local void @f1(i32 %i, ...) nounwind {
; CHECK-LABEL: f1:
; CHECK:       ! %bb.0: ! %entry
; CHECK-NEXT:    st %o5, [%sp+88]
; CHECK-NEXT:    st %o4, [%sp+84]
; CHECK-NEXT:    st %o3, [%sp+80]
; CHECK-NEXT:    st %o2, [%sp+76]
; CHECK-NEXT:    retl
; CHECK-NEXT:    st %o1, [%sp+72]
;
; USEFP-LABEL: f1:
; USEFP:       ! %bb.0: ! %entry
; USEFP-NEXT:    save %sp, -96, %sp
; USEFP-NEXT:    st %i5, [%fp+88]
; USEFP-NEXT:    st %i4, [%fp+84]
; USEFP-NEXT:    st %i3, [%fp+80]
; USEFP-NEXT:    st %i2, [%fp+76]
; USEFP-NEXT:    st %i1, [%fp+72]
; USEFP-NEXT:    ret
; USEFP-NEXT:    restore
entry:
  ret void
}

define dso_local i32 @main() local_unnamed_addr #0 {
; CHECK-LABEL: main:
; CHECK:         .cfi_startproc
; CHECK-NEXT:  ! %bb.0: ! %entry
; CHECK-NEXT:    st %i0, [%sp+32]
; CHECK-NEXT:    .cfi_offset %i0, 32
; CHECK-NEXT:    st %i7, [%sp+60]
; CHECK-NEXT:    .cfi_offset %i7, 60
; CHECK-NEXT:    mov %o7, %i7
; CHECK-NEXT:    .cfi_register 15, 31
; CHECK-NEXT:    add %sp, -96, %sp
; CHECK-NEXT:    .cfi_def_cfa_offset 96
; CHECK-NEXT:    sethi 1051648, %o1
; CHECK-NEXT:    mov 128, %o3
; CHECK-NEXT:    sethi 1052672, %o4
; CHECK-NEXT:    mov %g0, %i0
; CHECK-NEXT:    mov %i0, %o2
; CHECK-NEXT:    call f1
; CHECK-NEXT:    mov %i0, %o5
; CHECK-NEXT:    mov %i0, %o0
; CHECK-NEXT:    mov %i7, %o7
; CHECK-NEXT:    ld [%sp+128], %i0
; CHECK-NEXT:    ld [%sp+156], %i7
; CHECK-NEXT:    retl
; CHECK-NEXT:    add %sp, 96, %sp
;
; USEFP-LABEL: main:
; USEFP:         .cfi_startproc
; USEFP-NEXT:  ! %bb.0: ! %entry
; USEFP-NEXT:    st %l7, [%sp+28]
; USEFP-NEXT:    .cfi_offset %l7, 28
; USEFP-NEXT:    st %i0, [%sp+32]
; USEFP-NEXT:    .cfi_offset %i0, 32
; USEFP-NEXT:    st %i7, [%sp+60]
; USEFP-NEXT:    .cfi_offset %i7, 60
; USEFP-NEXT:    mov %o7, %i7
; USEFP-NEXT:    .cfi_register 15, 31
; USEFP-NEXT:    mov %sp, %l7
; USEFP-NEXT:    add %sp, -96, %sp
; USEFP-NEXT:    .cfi_def_cfa_offset 96
; USEFP-NEXT:    sethi 1051648, %o1
; USEFP-NEXT:    mov 128, %o3
; USEFP-NEXT:    sethi 1052672, %o4
; USEFP-NEXT:    mov %g0, %i0
; USEFP-NEXT:    mov %i0, %o2
; USEFP-NEXT:    call f1
; USEFP-NEXT:    mov %i0, %o5
; USEFP-NEXT:    mov %i0, %o0
; USEFP-NEXT:    mov %i7, %o7
; USEFP-NEXT:    mov %l7, %g1
; USEFP-NEXT:    ld [%g1+28], %l7
; USEFP-NEXT:    ld [%g1+32], %i0
; USEFP-NEXT:    ld [%g1+60], %i7
; USEFP-NEXT:    retl
; USEFP-NEXT:    mov %g1, %sp
entry:
  tail call void (i32, ...) @f1(i32 undef, double 1.600000e+01, i32 128, double 3.200000e+01)
  ret i32 0
}

declare i8* @llvm.returnaddress(i32)
declare i32 @func(i32)

attributes #0 = { "target-features"="+flat" }
