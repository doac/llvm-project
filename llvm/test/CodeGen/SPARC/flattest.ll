; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc < %s -mtriple=sparc | FileCheck %s

; TODO Add unwind information - remove from attributes - double and single reg. would be leaf functions that uses i0 should not be leaf.
; TODO bigstack - pr28982b

define i32 @test(i32 %a, i32 %b) #0 {
; CHECK-LABEL: test:
; CHECK:         .cfi_startproc
; CHECK-NEXT:  ! %bb.0: ! %entry
; CHECK-NEXT:    sethi %hi(0x1400), %g1
; CHECK-NEXT:    or %g1, 310, %g1
; CHECK-NEXT:    retl
; CHECK-NEXT:    smul %o1, %g1, %o0
entry:
  %0 = mul i32 %b, 5430
  ret i32 %0
}

define i32 @fptest(i32 %a, i32 %b) #1 {
; CHECK-LABEL: fptest:
; CHECK:         .cfi_startproc
; CHECK-NEXT:  ! %bb.0: ! %entry
; CHECK-NEXT:    st %l7, [%sp+28]
; CHECK-NEXT:    .cfi_offset %l7, 28
; CHECK-NEXT:    mov %sp, %l7
; CHECK-NEXT:    add %sp, -96, %sp
; CHECK-NEXT:    .cfi_def_cfa_offset 96
; CHECK-NEXT:    sethi %hi(0x1400), %g1
; CHECK-NEXT:    or %g1, 310, %g1
; CHECK-NEXT:    smul %o1, %g1, %o0
; CHECK-NEXT:    mov %l7, %g1
; CHECK-NEXT:    ld [%g1+28], %l7
; CHECK-NEXT:    retl
; CHECK-NEXT:    mov %g1, %sp
entry:
  %0 = mul i32 %b, 5430
  ret i32 %0
}

define i32 @docall() #0 {
; CHECK-LABEL: docall:
; CHECK:         .cfi_startproc
; CHECK-NEXT:  ! %bb.0: ! %entry
; CHECK-NEXT:    st %i7, [%sp+60]
; CHECK-NEXT:    .cfi_offset %i7, 60
; CHECK-NEXT:    mov %o7, %i7
; CHECK-NEXT:    .cfi_register 15, 31
; CHECK-NEXT:    add %sp, -96, %sp
; CHECK-NEXT:    .cfi_def_cfa_offset 96
; CHECK-NEXT:    call func
; CHECK-NEXT:    mov 1, %o0
; CHECK-NEXT:    mov 0, %o0
; CHECK-NEXT:    mov %i7, %o7
; CHECK-NEXT:    ld [%sp+156], %i7
; CHECK-NEXT:    retl
; CHECK-NEXT:    add %sp, 96, %sp
entry:
  %call = tail call i32 @func(i32 1) #4
  ret i32 0
}

define i32 @fpdocall() #1 {
; CHECK-LABEL: fpdocall:
; CHECK:         .cfi_startproc
; CHECK-NEXT:  ! %bb.0: ! %entry
; CHECK-NEXT:    st %l7, [%sp+28]
; CHECK-NEXT:    .cfi_offset %l7, 28
; CHECK-NEXT:    st %i7, [%sp+60]
; CHECK-NEXT:    .cfi_offset %i7, 60
; CHECK-NEXT:    mov %o7, %i7
; CHECK-NEXT:    .cfi_register 15, 31
; CHECK-NEXT:    mov %sp, %l7
; CHECK-NEXT:    add %sp, -96, %sp
; CHECK-NEXT:    .cfi_def_cfa_offset 96
; CHECK-NEXT:    call func
; CHECK-NEXT:    mov 1, %o0
; CHECK-NEXT:    mov 0, %o0
; CHECK-NEXT:    mov %i7, %o7
; CHECK-NEXT:    mov %l7, %g1
; CHECK-NEXT:    ld [%g1+28], %l7
; CHECK-NEXT:    ld [%g1+60], %i7
; CHECK-NEXT:    retl
; CHECK-NEXT:    mov %g1, %sp
entry:
  %call = tail call i32 @func(i32 1) #4
  ret i32 0
}

define i32 @storeonstack(i32 %a) #0 {
; CHECK-LABEL: storeonstack:
; CHECK:         .cfi_startproc
; CHECK-NEXT:  ! %bb.0: ! %entry
; CHECK-NEXT:    add %sp, -96, %sp
; CHECK-NEXT:    .cfi_def_cfa_offset 96
; CHECK-NEXT:    mov 0, %g1
; CHECK-NEXT:    st %o0, [%sp+92]
; CHECK-NEXT:    mov %g1, %o0
; CHECK-NEXT:    retl
; CHECK-NEXT:    add %sp, 96, %sp
entry:
  %val = alloca i32, align 4
  store volatile i32 %a, i32* %val
  ret i32 0
}

define i32 @fpstoreonstack(i32 %a) #1 {
; CHECK-LABEL: fpstoreonstack:
; CHECK:         .cfi_startproc
; CHECK-NEXT:  ! %bb.0: ! %entry
; CHECK-NEXT:    st %l7, [%sp+28]
; CHECK-NEXT:    .cfi_offset %l7, 28
; CHECK-NEXT:    mov %sp, %l7
; CHECK-NEXT:    add %sp, -96, %sp
; CHECK-NEXT:    .cfi_def_cfa_offset 96
; CHECK-NEXT:    mov 0, %g1
; CHECK-NEXT:    st %o0, [%l7+-4]
; CHECK-NEXT:    mov %g1, %o0
; CHECK-NEXT:    mov %l7, %g1
; CHECK-NEXT:    ld [%g1+28], %l7
; CHECK-NEXT:    retl
; CHECK-NEXT:    mov %g1, %sp
entry:
  %val = alloca i32, align 4
  store volatile i32 %a, i32* %val
  ret i32 0
}

define i32 @storeonstackanddocall(i32 %a) #0 {
; CHECK-LABEL: storeonstackanddocall:
; CHECK:         .cfi_startproc
; CHECK-NEXT:  ! %bb.0: ! %entry
; CHECK-NEXT:    st %i7, [%sp+60]
; CHECK-NEXT:    .cfi_offset %i7, 60
; CHECK-NEXT:    mov %o7, %i7
; CHECK-NEXT:    .cfi_register 15, 31
; CHECK-NEXT:    add %sp, -96, %sp
; CHECK-NEXT:    .cfi_def_cfa_offset 96
; CHECK-NEXT:    st %o0, [%sp+92]
; CHECK-NEXT:    call func
; CHECK-NEXT:    mov 1, %o0
; CHECK-NEXT:    mov 0, %o0
; CHECK-NEXT:    mov %i7, %o7
; CHECK-NEXT:    ld [%sp+156], %i7
; CHECK-NEXT:    retl
; CHECK-NEXT:    add %sp, 96, %sp
entry:
  %val = alloca i32, align 4
  store volatile i32 %a, i32* %val
  %call = tail call i32 @func(i32 1)
  ret i32 0
}

define i32 @fpstoreonstackanddocall(i32 %a) #1 {
; CHECK-LABEL: fpstoreonstackanddocall:
; CHECK:         .cfi_startproc
; CHECK-NEXT:  ! %bb.0: ! %entry
; CHECK-NEXT:    st %l7, [%sp+28]
; CHECK-NEXT:    .cfi_offset %l7, 28
; CHECK-NEXT:    st %i7, [%sp+60]
; CHECK-NEXT:    .cfi_offset %i7, 60
; CHECK-NEXT:    mov %o7, %i7
; CHECK-NEXT:    .cfi_register 15, 31
; CHECK-NEXT:    mov %sp, %l7
; CHECK-NEXT:    add %sp, -96, %sp
; CHECK-NEXT:    .cfi_def_cfa_offset 96
; CHECK-NEXT:    st %o0, [%l7+-4]
; CHECK-NEXT:    call func
; CHECK-NEXT:    mov 1, %o0
; CHECK-NEXT:    mov 0, %o0
; CHECK-NEXT:    mov %i7, %o7
; CHECK-NEXT:    mov %l7, %g1
; CHECK-NEXT:    ld [%g1+28], %l7
; CHECK-NEXT:    ld [%g1+60], %i7
; CHECK-NEXT:    retl
; CHECK-NEXT:    mov %g1, %sp
entry:
  %val = alloca i32, align 4
  store volatile i32 %a, i32* %val
  %call = tail call i32 @func(i32 1)
  ret i32 0
}

%struct.foo_t = type { i32, i32, i32 }

define void @incomingsret(%struct.foo_t* noalias sret %agg.result, i32 %a, i32 %b, i32 %c) #0 {
; CHECK-LABEL: incomingsret:
; CHECK:         .cfi_startproc
; CHECK-NEXT:  ! %bb.0: ! %entry
; CHECK-NEXT:    ld [%sp+64], %g1
; CHECK-NEXT:    st %o0, [%g1]
; CHECK-NEXT:    st %o1, [%g1+4]
; CHECK-NEXT:    st %o2, [%g1+8]
; CHECK-NEXT:    jmp %o7+12
; CHECK-NEXT:    mov %g1, %o0
entry:
  %0 = getelementptr inbounds %struct.foo_t, %struct.foo_t* %agg.result, i32 0, i32 0
  store i32 %a, i32* %0, align 4
  %1 = getelementptr inbounds %struct.foo_t, %struct.foo_t* %agg.result, i32 0, i32 1
  store i32 %b, i32* %1, align 4
  %2 = getelementptr inbounds %struct.foo_t, %struct.foo_t* %agg.result, i32 0, i32 2
  store i32 %c, i32* %2, align 4
  ret void
}

define void @fpincomingsret(%struct.foo_t* noalias sret %agg.result, i32 %a, i32 %b, i32 %c) #1 {
; CHECK-LABEL: fpincomingsret:
; CHECK:         .cfi_startproc
; CHECK-NEXT:  ! %bb.0: ! %entry
; CHECK-NEXT:    st %l7, [%sp+28]
; CHECK-NEXT:    .cfi_offset %l7, 28
; CHECK-NEXT:    mov %sp, %l7
; CHECK-NEXT:    add %sp, -96, %sp
; CHECK-NEXT:    .cfi_def_cfa_offset 96
; CHECK-NEXT:    ld [%l7+64], %g1
; CHECK-NEXT:    st %o0, [%g1]
; CHECK-NEXT:    st %o1, [%g1+4]
; CHECK-NEXT:    st %o2, [%g1+8]
; CHECK-NEXT:    mov %g1, %o0
; CHECK-NEXT:    mov %l7, %g1
; CHECK-NEXT:    ld [%g1+28], %l7
; CHECK-NEXT:    jmp %o7+12
; CHECK-NEXT:    mov %g1, %sp
entry:
  %0 = getelementptr inbounds %struct.foo_t, %struct.foo_t* %agg.result, i32 0, i32 0
  store i32 %a, i32* %0, align 4
  %1 = getelementptr inbounds %struct.foo_t, %struct.foo_t* %agg.result, i32 0, i32 1
  store i32 %b, i32* %1, align 4
  %2 = getelementptr inbounds %struct.foo_t, %struct.foo_t* %agg.result, i32 0, i32 2
  store i32 %c, i32* %2, align 4
  ret void
}

define i8* @getret() #0 {
; CHECK-LABEL: getret:
; CHECK:         .cfi_startproc
; CHECK-NEXT:  ! %bb.0: ! %entry
; CHECK-NEXT:    st %i7, [%sp+60]
; CHECK-NEXT:    .cfi_offset %i7, 60
; CHECK-NEXT:    mov %o7, %i7
; CHECK-NEXT:    .cfi_register 15, 31
; CHECK-NEXT:    mov %i7, %o0
; CHECK-NEXT:    mov %i7, %o7
; CHECK-NEXT:    retl
; CHECK-NEXT:    ld [%sp+60], %i7
entry:
  %0 = tail call i8* @llvm.returnaddress(i32 0)
  ret i8* %0
}

define i8* @fpgetret() #1 {
; CHECK-LABEL: fpgetret:
; CHECK:         .cfi_startproc
; CHECK-NEXT:  ! %bb.0: ! %entry
; CHECK-NEXT:    st %l7, [%sp+28]
; CHECK-NEXT:    .cfi_offset %l7, 28
; CHECK-NEXT:    st %i7, [%sp+60]
; CHECK-NEXT:    .cfi_offset %i7, 60
; CHECK-NEXT:    mov %o7, %i7
; CHECK-NEXT:    .cfi_register 15, 31
; CHECK-NEXT:    mov %sp, %l7
; CHECK-NEXT:    add %sp, -96, %sp
; CHECK-NEXT:    .cfi_def_cfa_offset 96
; CHECK-NEXT:    mov %i7, %o0
; CHECK-NEXT:    mov %i7, %o7
; CHECK-NEXT:    mov %l7, %g1
; CHECK-NEXT:    ld [%g1+28], %l7
; CHECK-NEXT:    ld [%g1+60], %i7
; CHECK-NEXT:    retl
; CHECK-NEXT:    mov %g1, %sp
entry:
  %0 = tail call i8* @llvm.returnaddress(i32 0)
  ret i8* %0
}

define i8* @getretandstoreonstack() #0 {
; CHECK-LABEL: getretandstoreonstack:
; CHECK:         .cfi_startproc
; CHECK-NEXT:  ! %bb.0: ! %entry
; CHECK-NEXT:    st %i7, [%sp+60]
; CHECK-NEXT:    .cfi_offset %i7, 60
; CHECK-NEXT:    mov %o7, %i7
; CHECK-NEXT:    .cfi_register 15, 31
; CHECK-NEXT:    add %sp, -96, %sp
; CHECK-NEXT:    .cfi_def_cfa_offset 96
; CHECK-NEXT:    st %g0, [%sp+92]
; CHECK-NEXT:    mov %i7, %o0
; CHECK-NEXT:    mov %i7, %o7
; CHECK-NEXT:    ld [%sp+156], %i7
; CHECK-NEXT:    retl
; CHECK-NEXT:    add %sp, 96, %sp
entry:
  %val = alloca i32, align 4
  store volatile i32 0, i32* %val
  %0 = tail call i8* @llvm.returnaddress(i32 0)
  ret i8* %0
}

define i8* @fpgetretandstoreonstack() #1 {
; CHECK-LABEL: fpgetretandstoreonstack:
; CHECK:         .cfi_startproc
; CHECK-NEXT:  ! %bb.0: ! %entry
; CHECK-NEXT:    st %l7, [%sp+28]
; CHECK-NEXT:    .cfi_offset %l7, 28
; CHECK-NEXT:    st %i7, [%sp+60]
; CHECK-NEXT:    .cfi_offset %i7, 60
; CHECK-NEXT:    mov %o7, %i7
; CHECK-NEXT:    .cfi_register 15, 31
; CHECK-NEXT:    mov %sp, %l7
; CHECK-NEXT:    add %sp, -96, %sp
; CHECK-NEXT:    .cfi_def_cfa_offset 96
; CHECK-NEXT:    st %g0, [%l7+-4]
; CHECK-NEXT:    mov %i7, %o0
; CHECK-NEXT:    mov %i7, %o7
; CHECK-NEXT:    mov %l7, %g1
; CHECK-NEXT:    ld [%g1+28], %l7
; CHECK-NEXT:    ld [%g1+60], %i7
; CHECK-NEXT:    retl
; CHECK-NEXT:    mov %g1, %sp
entry:
  %val = alloca i32, align 4
  store volatile i32 0, i32* %val
  %0 = tail call i8* @llvm.returnaddress(i32 0)
  ret i8* %0
}

define internal fastcc i32 @Callee(i32 %i) unnamed_addr #0 {
; CHECK-LABEL: Callee:
; CHECK:         .cfi_startproc
; CHECK-NEXT:  ! %bb.0: ! %entry
; CHECK-NEXT:    st %l7, [%sp+28]
; CHECK-NEXT:    .cfi_offset %l7, 28
; CHECK-NEXT:    mov %sp, %l7
; CHECK-NEXT:    add %sp, -96, %sp
; CHECK-NEXT:    .cfi_def_cfa_offset 96
; CHECK-NEXT:    cmp %o0, 0
; CHECK-NEXT:    be,a .LBB14_3
; CHECK-NEXT:    mov 0, %o0
; CHECK-NEXT:  ! %bb.2: ! %if.then
; CHECK-NEXT:    mov %sp, %g1
; CHECK-NEXT:    add %g1, -4008, %sp
; CHECK-NEXT:    ba .LBB14_3
; CHECK-NEXT:    ld [%g1+-3912], %o0
; CHECK-NEXT:  ! %bb.1:
; CHECK-NEXT:    mov 0, %o0
; CHECK-NEXT:  .LBB14_3: ! %return
; CHECK-NEXT:    mov %l7, %g1
; CHECK-NEXT:    ld [%g1+28], %l7
; CHECK-NEXT:    retl
; CHECK-NEXT:    mov %g1, %sp
entry:
  %cmp = icmp eq i32 %i, 0
  br i1 %cmp, label %return, label %if.then
if.then:
  %0 = alloca [1000 x i32], align 8
  %.sub = getelementptr inbounds [1000 x i32], [1000 x i32]* %0, i32 0, i32 0
  %conv = load i32, i32* %.sub, align 8
;  %conv = sext i8 %1 to i32
  br label %return

return:
  %retval.0 = phi i32 [ %conv, %if.then ], [ 0, %entry ]
  ret i32  %retval.0
}

define internal fastcc i32 @fpCallee(i32 %i) unnamed_addr #1 {
; CHECK-LABEL: fpCallee:
; CHECK:         .cfi_startproc
; CHECK-NEXT:  ! %bb.0: ! %entry
; CHECK-NEXT:    st %l7, [%sp+28]
; CHECK-NEXT:    .cfi_offset %l7, 28
; CHECK-NEXT:    mov %sp, %l7
; CHECK-NEXT:    add %sp, -96, %sp
; CHECK-NEXT:    .cfi_def_cfa_offset 96
; CHECK-NEXT:    cmp %o0, 0
; CHECK-NEXT:    be,a .LBB15_3
; CHECK-NEXT:    mov 0, %o0
; CHECK-NEXT:  ! %bb.2: ! %if.then
; CHECK-NEXT:    mov %sp, %g1
; CHECK-NEXT:    add %g1, -4008, %sp
; CHECK-NEXT:    ba .LBB15_3
; CHECK-NEXT:    ld [%g1+-3912], %o0
; CHECK-NEXT:  ! %bb.1:
; CHECK-NEXT:    mov 0, %o0
; CHECK-NEXT:  .LBB15_3: ! %return
; CHECK-NEXT:    mov %l7, %g1
; CHECK-NEXT:    ld [%g1+28], %l7
; CHECK-NEXT:    retl
; CHECK-NEXT:    mov %g1, %sp
entry:
  %cmp = icmp eq i32 %i, 0
  br i1 %cmp, label %return, label %if.then
if.then:
  %0 = alloca [1000 x i32], align 8
  %.sub = getelementptr inbounds [1000 x i32], [1000 x i32]* %0, i32 0, i32 0
  %conv = load i32, i32* %.sub, align 8
;  %conv = sext i8 %1 to i32
  br label %return

return:
  %retval.0 = phi i32 [ %conv, %if.then ], [ 0, %entry ]
  ret i32  %retval.0
}

define <2 x i32> @bitcast() #0 {
; CHECK-LABEL: bitcast:
; CHECK:         .cfi_startproc
; CHECK-NEXT:  ! %bb.0:
; CHECK-NEXT:    sethi %hi(0x40140000), %o0
; CHECK-NEXT:    retl
; CHECK-NEXT:    mov 0, %o1
  %1 = bitcast double 5.0 to <2 x i32>
  ret <2 x i32> %1
}

define <2 x i32> @fpbitcast() #1 {
; CHECK-LABEL: fpbitcast:
; CHECK:         .cfi_startproc
; CHECK-NEXT:  ! %bb.0:
; CHECK-NEXT:    st %l7, [%sp+28]
; CHECK-NEXT:    .cfi_offset %l7, 28
; CHECK-NEXT:    mov %sp, %l7
; CHECK-NEXT:    add %sp, -96, %sp
; CHECK-NEXT:    .cfi_def_cfa_offset 96
; CHECK-NEXT:    sethi %hi(0x40140000), %o0
; CHECK-NEXT:    mov 0, %o1
; CHECK-NEXT:    mov %l7, %g1
; CHECK-NEXT:    ld [%g1+28], %l7
; CHECK-NEXT:    retl
; CHECK-NEXT:    mov %g1, %sp
  %1 = bitcast double 5.0 to <2 x i32>
  ret <2 x i32> %1
}

define dso_local void @f1(i32 %i, ...) nounwind {
; CHECK-LABEL: f1:
; CHECK:       ! %bb.0: ! %entry
; CHECK-NEXT:    st %o5, [%sp+88]
; CHECK-NEXT:    st %o4, [%sp+84]
; CHECK-NEXT:    st %o3, [%sp+80]
; CHECK-NEXT:    st %o2, [%sp+76]
; CHECK-NEXT:    retl
; CHECK-NEXT:    st %o1, [%sp+72]
entry:
  ret void
}

define dso_local i32 @main() local_unnamed_addr #0 {
; CHECK-LABEL: main:
; CHECK:         .cfi_startproc
; CHECK-NEXT:  ! %bb.0: ! %entry
; CHECK-NEXT:    st %i0, [%sp+32]
; CHECK-NEXT:    .cfi_offset %i0, 32
; CHECK-NEXT:    st %i7, [%sp+60]
; CHECK-NEXT:    .cfi_offset %i7, 60
; CHECK-NEXT:    mov %o7, %i7
; CHECK-NEXT:    .cfi_register 15, 31
; CHECK-NEXT:    add %sp, -96, %sp
; CHECK-NEXT:    .cfi_def_cfa_offset 96
; CHECK-NEXT:    sethi %hi(0x40300000), %o1
; CHECK-NEXT:    mov 128, %o3
; CHECK-NEXT:    sethi %hi(0x40400000), %o4
; CHECK-NEXT:    mov 0, %i0
; CHECK-NEXT:    mov %i0, %o2
; CHECK-NEXT:    call f1
; CHECK-NEXT:    mov %i0, %o5
; CHECK-NEXT:    mov %i0, %o0
; CHECK-NEXT:    mov %i7, %o7
; CHECK-NEXT:    ld [%sp+128], %i0
; CHECK-NEXT:    ld [%sp+156], %i7
; CHECK-NEXT:    retl
; CHECK-NEXT:    add %sp, 96, %sp
entry:
  tail call void (i32, ...) @f1(i32 undef, double 1.600000e+01, i32 128, double 3.200000e+01)
  ret i32 0
}

define dso_local i32 @fpmain() local_unnamed_addr #1 {
; CHECK-LABEL: fpmain:
; CHECK:         .cfi_startproc
; CHECK-NEXT:  ! %bb.0: ! %entry
; CHECK-NEXT:    st %l7, [%sp+28]
; CHECK-NEXT:    .cfi_offset %l7, 28
; CHECK-NEXT:    st %i0, [%sp+32]
; CHECK-NEXT:    .cfi_offset %i0, 32
; CHECK-NEXT:    st %i7, [%sp+60]
; CHECK-NEXT:    .cfi_offset %i7, 60
; CHECK-NEXT:    mov %o7, %i7
; CHECK-NEXT:    .cfi_register 15, 31
; CHECK-NEXT:    mov %sp, %l7
; CHECK-NEXT:    add %sp, -96, %sp
; CHECK-NEXT:    .cfi_def_cfa_offset 96
; CHECK-NEXT:    sethi %hi(0x40300000), %o1
; CHECK-NEXT:    mov 128, %o3
; CHECK-NEXT:    sethi %hi(0x40400000), %o4
; CHECK-NEXT:    mov 0, %i0
; CHECK-NEXT:    mov %i0, %o2
; CHECK-NEXT:    call f1
; CHECK-NEXT:    mov %i0, %o5
; CHECK-NEXT:    mov %i0, %o0
; CHECK-NEXT:    mov %i7, %o7
; CHECK-NEXT:    mov %l7, %g1
; CHECK-NEXT:    ld [%g1+28], %l7
; CHECK-NEXT:    ld [%g1+32], %i0
; CHECK-NEXT:    ld [%g1+60], %i7
; CHECK-NEXT:    retl
; CHECK-NEXT:    mov %g1, %sp
entry:
  tail call void (i32, ...) @f1(i32 undef, double 1.600000e+01, i32 128, double 3.200000e+01)
  ret i32 0
}

declare i8* @llvm.returnaddress(i32)
declare i32 @func(i32)

attributes #0 = { "target-features"="+flat" "no-frame-pointer-elim"="false" }
attributes #1 = { "target-features"="+flat" "no-frame-pointer-elim"="true" }
